=== Demo - The Images Microservice

A Simple REST Repository App for managing Images

NOTE: This is much the same as the Actors app we build previously

==== Create the app and the config for local testing

. Create a small CRUD JPA Repository app
+
----
curl https://start.spring.io/starter.zip -d bootVersion=2.0.0.M5 \
    -d dependencies=web,actuator,jpa,data-rest,mysql,hsql \
    -d groupId=com.springdeveloper.k8s -d artifactId=images \
    -d name=images -d baseDir=images -o images.zip
unzip images.zip
cd images
----

. Add an Image Entity
+
.Image.java
[source,java]
----
package com.springdeveloper.k8s.images;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Image {

	@Id
	@GeneratedValue
	Long id;

	String url;

	String name;

	int size;

	public Long getId() {
		return id;
	}

	public String getUrl() {
		return url;
	}

	public void setUrl(String url) {
		this.url = url;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getSize() {
		return size;
	}

	public void setSize(int size) {
		this.size = size;
	}
}
----

. Add an ImageRepository
+
.ImageRepository.java
[source,java]
----
package com.springdeveloper.k8s.images;

import java.util.List;

import org.springframework.data.repository.PagingAndSortingRepository;
import org.springframework.data.repository.query.Param;

public interface ImageRepository extends PagingAndSortingRepository<Image, Long> {

	List<Image> findByName(@Param("name") String name);

}
----

. Create default properties file for running app locally
+
.application-default.properties
[source,props]
----
endpoints.env.enabled=true
spring.datasource.url=jdbc:hsqldb:file:target/testdb
spring.datasource.username=sa
spring.jpa.hibernate.ddl-auto=create
spring.datasource.initialize=true
----

. Build and run the app locally
+
----
./mvnw clean package
java -jar target/images-0.0.1-SNAPSHOT.jar
----

. You can add image records:
+
----
curl -i -X POST -H "Content-Type:application/json" -d "{  \"url\" : \"https://www.evolutionary.org/wp-content/uploads/2014/04/Dolph-Lundgren-boxer-197x300.jpg\", \"name\" : \"Dolph Lundgren\",  \"size\" : 13923 }" http://localhost:8080/images
----

. Test
+
----
curl http://localhost:8080/images | python -m json.tool
----

==== Add Kubernetes configuration

. Add config properties for running on Kubernetes
+
NOTE: We will be using the same MySQL database that the Actors app is using - see link:demo-actors.adoc#create-a-mysql-database-deployment-and-service[Create a MySQL database deployment and service]
+
.application-kubernetes.properties
[source,props]
----
endpoints.env.enabled=true
spring.jpa.hibernate.ddl-auto=update
spring.datasource.initialize=false
----

. Add `Dockerfile` and Docker Maven plug-in to the `pom.xml`. We are using the most recent https://github.com/spotify/dockerfile-maven[Spotify plugin].
+
.Dockerfile
[source]
----
FROM java:8-alpine
VOLUME /tmp
ARG JAR_FILE
ADD ./target/${JAR_FILE} /images.jar
RUN sh -c 'touch /images.jar'
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/images.jar"]
----
+
.pom.xml
[source,xml]
----
...
	<build>
		<plugins>
...
 			<plugin>
				<groupId>com.spotify</groupId>
				<artifactId>dockerfile-maven-plugin</artifactId>
				<version>1.3.6</version>
				<configuration>
					<repository>${user.name}/${project.artifactId}</repository>
					<tag>${project.version}</tag>
					<buildArgs>
						<JAR_FILE>${project.build.finalName}.jar</JAR_FILE>
					</buildArgs>
				</configuration>
			</plugin>
...
		</plugins>
	</build>
...
----

. Downgrade Hibernate version
+
WARNING: We need to downgrade the Hibernate version. The most recent version throws an error when using "spring.jpa.hibernate.ddl-auto=update" and the tables already exist.
+
.pom.xml
[source,xml]
----
...
		<!-- Downgrade Hibernate so we can use "spring.jpa.hibernate.ddl-auto=update" -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>4.3.10.Final</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-entitymanager</artifactId>
			<version>4.3.10.Final</version>
		</dependency>
...
----

. Create the Kubernetes configuration files for the app
+
.config/images-svc.yaml
[source,yaml]
----
kind: Service
apiVersion: v1
metadata:
  name: images
  labels:
    app: images
spec:
  # If you are running k8s on a local dev box or using minikube, you can use type NodePort instead of LoadBalancer
  type: NodePort
  ports:
    - port: 80
  selector:
    app: images
----
+
.config/images-deployment.yaml
[source,yaml]
----
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: images
  labels:
    app: images
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: images
    spec:
      containers:
      - name: images
        image: trisberg/images:0.0.1-SNAPSHOT
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
        resources:
          limits:
            cpu: 1.0
            memory: 1024Mi
          requests:
            cpu: 0.5
            memory: 640Mi
        livenessProbe:
          httpGet:
            path: /application/status
            port: 80
          initialDelaySeconds: 90
          periodSeconds: 15
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /application/status
            port: 80
          initialDelaySeconds: 45
          periodSeconds: 15
          timeoutSeconds: 5
        env:
        - name: SERVER_PORT
          value: '80'
        - name: SPRING_PROFILES_ACTIVE
          value: kubernetes
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql
              key: mysql-root-password
        volumeMounts:
        - name: application-config 
          mountPath: "/config" 
          readOnly: true
      volumes:
      - name: application-config
        configMap:
          name: images 
          items:
          - key: application.yaml 
            path: application.yaml
----
+
.config/images-config.yaml
[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: images
  labels:
    app: images
data:
  application.yaml: |-
    security:
      basic:
        enabled: false
    spring:
      datasource:
        url: jdbc:mysql://${MYSQL_SERVICE_HOST}:${MYSQL_SERVICE_PORT}/mysql
        username: root
        password: ${mysql-root-password}
        driverClassName: com.mysql.jdbc.Driver
        testOnBorrow: true
        validationQuery: "SELECT 1"
----

==== Deploy app to Kubernetes and test

. Check that the MySQL service is running
+
----
kubectl get all -l app=mysql
----

. Build app and Docker image
+
NOTE: We are sharing the Docker environment used by Minikube
+
----
eval $(minikube docker-env)
./mvnw clean package dockerfile:build
----

. Deploy app to k8s
+
----
kubectl apply -f config/
----

. Get status
+
----
$ kubectl get all
----

. Add some image records
+
We need to look up the IP address of the service and then POST some data to it and test retreiving them:
+
[source,bash]
----
export IMAGES_URL="$(minikube service images --url)"
curl -i -X POST -H "Content-Type:application/json" -d "{  \"url\" : \"https://www.evolutionary.org/wp-content/uploads/2014/04/Dolph-Lundgren-boxer-197x300.jpg\", \"name\" : \"Dolph Lundgren\",  \"size\" : 13923 }" $IMAGES_URL/images
curl $IMAGES_URL/images
----

